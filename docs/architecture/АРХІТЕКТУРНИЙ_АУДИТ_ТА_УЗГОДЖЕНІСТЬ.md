# ~~DEPRECATED~~ Архітектурний аудит та узгодженість

> **DEPRECATED:** Цей документ замінено на `АРХІТЕКТУРНИЙ_АУДИТ_ТА_УЗГОДЖЕНІСТЬ_FINAL.md`.
> Зберігається для історичного контексту.

> Створено: 2026-02-14
> Автор: Головний архітектор системи
> Статус: ~~Аудит узгодженості архітектурної документації~~ **DEPRECATED**
> Мова: Українська (канонічна)
> Метод: Логічний аудит cross-document consistency

---

## Перелік аудитованих документів

| Документ | Скорочення у цьому аудиті |
|----------|--------------------------|
| АРХІТЕКТУРНА_БАЗА_СИСТЕМИ.md | [БАЗА] |
| ЦІЛЬОВА_АРХІТЕКТУРА_MASTRA_INNGEST.md | [ЦІЛЬОВА] |
| КОНТРАКТ_АГЕНТА_V1.md | [КОНТРАКТ] |
| INBOX_ТА_PROPOSAL_АРХІТЕКТУРА.md | [INBOX] |
| DRAKON_ІНТЕГРАЦІЯ_ТА_МОДЕЛЬ_ВИКОНАННЯ_АГЕНТА.md | [DRAKON] |
| LOVABLE_УЗГОДЖЕННЯ_З_RUNTIME_АРХІТЕКТУРОЮ.md | [FRONTEND] |
| ПЛАН_МІГРАЦІЇ_GH_AW_НА_MASTRA_INNGEST.md | [МІГРАЦІЯ] |
| MANIFESTO.md | [МАНІФЕСТ] |

---

## РОЗДІЛ 1 — Перевірка інваріантів маніфесту

### Інваріант 1: Folder = Agent (агент є storage-defined entity)

**ПІДТВЕРДЖЕНО**

[МАНІФЕСТ] §2.2: "Папка = Агент (або Контейнер агента)". [КОНТРАКТ] §1.1 визначає канонічну структуру: `garden-agents/agents/<slug>/` з `_agent.md` як маркером існування. [КОНТРАКТ] §1.3: "Папка без `_agent.md` — це не агент". [DRAKON] §2.1 повторює ту ж структуру.

Усі документи узгоджені: агент = папка у MinIO з обов'язковим `_agent.md`.

**Застереження:** [МАНІФЕСТ] §2.2 каже "Якщо в папці немає явного файлу агента — папка все одно є агентом за замовчуванням (read-only knowledge agent)". [КОНТРАКТ] §1.3 каже протилежне: "Папка без `_agent.md` — це не агент". Це протиріччя між маніфестом та контрактом. Маніфест описує ідеологію (будь-яка папка = потенційний агент). Контракт описує runtime реальність (агент потребує `_agent.md` для активації). Це не конфлікт, якщо інтерпретувати маніфест як ідеологічний принцип, а контракт як технічний — але розбіжність має бути явно зафіксована.

---

### Інваріант 2: MinIO є єдиним canonical source of truth

**ПІДТВЕРДЖЕНО**

[ЦІЛЬОВА] §1: "MinIO залишається канонічним сховищем". [КОНТРАКТ] §0: "Агент існує як набір файлів у MinIO". [DRAKON] Інваріант 3: "Storage (MinIO) є єдиним source of truth". [INBOX] §0: "Proposal є єдиним дозволеним механізмом змін canonical storage". [FRONTEND] Інваріант 1: "Frontend комунікує виключно через Worker". [МІГРАЦІЯ] Інваріант 1: "MinIO залишається єдиним канонічним сховищем".

Усі 7 документів послідовно підтверджують MinIO як canonical storage.

**Застереження:** [БАЗА] §2 зазначає, що Git (GitHub) є джерелом істини для контенту нотаток та DRAKON-діаграм. Це подвійний source of truth: MinIO для агентних артефактів, Git для нотаток. Поточна архітектура це визнає, але при переході до Inbox-driven model нотатки теж будуть модифікуватися через proposals, які зберігаються у MinIO, а apply йде у Git. Два canonical sources потребують чіткого розмежування: **Git = notes content**, **MinIO = agent system + proposals + runs + audit**. Це розмежування імпліцитне, але не зафіксоване як явний інваріант.

---

### Інваріант 3: _agent.md і pseudocode є behavioral contract

**НЕПОВНІСТЮ ВИЗНАЧЕНО**

[КОНТРАКТ] визначає `_agent.md` як "єдину точку входу для runtime" (§2). [DRAKON] визначає pseudocode як "декларативний behavioral contract" (§2.2) і стверджує, що `pseudocode.md` — окремий файл у папці агента (§2.1).

**Проблема:** Існує неузгодженість щодо ролі `pseudocode.md` як окремого файлу:

1. [DRAKON] §2.1 показує `pseudocode.md` як окремий файл у папці агента, поряд з `_agent.md`.
2. [DRAKON] §2.2 стверджує: "Runtime читає цей файл для визначення послідовності дій" — тобто runtime читає `pseudocode.md`.
3. [DRAKON] §3.3 стверджує протилежне: "Runtime завантажує `_agent.md` з MinIO" і використовує Markdown body як instructions.
4. [КОНТРАКТ] §1.1 не перелічує `pseudocode.md` у канонічній структурі папки агента.
5. [DRAKON] §2.2 (_agent.md section): "Markdown body = pseudocode.md content, можливо з додатковим контекстом".

Питання без відповіді: Runtime читає `pseudocode.md` окремо чи лише `_agent.md` (де pseudocode вбудований)? Якщо обидва — яке має пріоритет? Механізм синхронізації між `pseudocode.md` і body `_agent.md` не визначений.

---

### Інваріант 4: Mastra і Inngest є runtime layers, не джерелом істини

**ПІДТВЕРДЖЕНО**

[ЦІЛЬОВА] §1: "Mastra і Inngest НЕ є джерелами істини. Вони є виконавцями та оркестраторами". [ЦІЛЬОВА] §2.4: "Mastra не зберігає стан між запусками". [ЦІЛЬОВА] §2.3: "Inngest зберігає тимчасовий стан workflow (step results)... цей стан є ефемерним". [КОНТРАКТ] §0: "Runtime є інтерпретатором, не власником". [DRAKON] §5: підтверджує Mastra як read-only consumer, Inngest як оркестратор без знання змісту. [МІГРАЦІЯ] Інваріант 2: повторює.

Усі документи послідовно узгоджені.

---

### Інваріант 5: Proposal lifecycle є єдиним механізмом mutation canonical state

**НЕПОВНІСТЮ ВИЗНАЧЕНО**

[INBOX] §0: "Proposal є єдиним дозволеним механізмом змін canonical storage". [DRAKON] Інваріант 7: "Агент може впливати на систему лише через proposal". [ЦІЛЬОВА] §1: "Будь-який результат агента проходить через proposal → approval → apply". [FRONTEND] Інваріант 3: "Будь-яка зміна canonical storage, ініційована з UI, проходить через повний Inbox → Proposal → Consent Gate → Apply цикл".

**Проблема: tool `write-memory` порушує цей інваріант.**

[КОНТРАКТ] §1.2 визначає директорію `memory/` у папці агента з правом запису для Mastra: "Хто пише: Mastra (tool: `write-memory`)". [КОНТРАКТ] §2.2 включає `write-memory` у перелік tools.

`memory/` знаходиться у MinIO (`garden-agents/agents/<slug>/memory/`). Це canonical storage. Але `write-memory` записує напряму у MinIO, минаючи Inbox → Proposal → Approval → Apply lifecycle.

Це означає одне з двох:
- (a) `memory/` — виняток з proposal lifecycle (допустимий, але не зафіксований як виняток)
- (b) `write-memory` має проходити через proposal lifecycle (але це зробить агента неспроможним накопичувати досвід ефективно)

Архітектурне рішення не зафіксоване. Це undefined behavior.

Аналогічна проблема з `runs/`: результати виконання записуються у MinIO (`runs/<id>/steps/`, `manifest.json`) напряму Inngest/Mastra, минаючи proposal lifecycle. Це логічно обґрунтовано (run log — не зміна знань, а запис факту), але не зафіксовано як явний виняток.

---

### Інваріант 6: Frontend (Lovable) є projection layer, не authority layer

**ПІДТВЕРДЖЕНО**

[FRONTEND] §1: "Frontend є проєкцією стану системи, не джерелом стану". [FRONTEND] §4: "Backend є авторитетом". [FRONTEND] Інваріант 2: "Frontend є read-heavy, write-light система". [ЦІЛЬОВА] §2.5: "Frontend відображає стан агентної системи, але не керує виконанням напряму". [МАНІФЕСТ] §10: "UI — лише проекція ролі".

Усі документи послідовно узгоджені.

---

### Інваріант 7: DRAKON визначає behavioral logic, runtime лише інтерпретує

**ПІДТВЕРДЖЕНО** з застереженням

[DRAKON] §1.1: "DRAKON є канонічним інструментом визначення логіки агента". [DRAKON] Інваріант 1: "DRAKON-діаграма є авторитетним джерелом логіки агента". [DRAKON] Інваріант 5: "Ланцюг трансформацій однонаправлений". [КОНТРАКТ] §3: підтверджує два шляхи створення агента (Path A — вручну, Path B — через DRAKON).

**Застереження:** [КОНТРАКТ] §3.1 визначає Path A: "Людина → _agent.md (вручну)". Це означає, що DRAKON **не є обов'язковим**. Агент може бути створений без DRAKON-діаграми. У цьому випадку behavioral logic визначається напряму у Markdown body `_agent.md`, а не через DRAKON.

[DRAKON] формулює інваріанти так, ніби DRAKON — єдиний шлях ("DRAKON-діаграма є авторитетним джерелом логіки"), але [КОНТРАКТ] допускає альтернативний шлях. Це не конфлікт, якщо інтерпретувати [DRAKON] інваріанти як "коли DRAKON використовується — він є авторитетним". Але формулювання потребує уточнення для уникнення ambiguity.

---

## РОЗДІЛ 2 — Перевірка authority boundaries

### 2.1 Storage authority (MinIO)

**Визначено чітко.**

MinIO є passive storage. Не виконує логіки, не валідує дані, не надсилає повідомлень ([ЦІЛЬОВА] §5.2). Єдиний, хто пише у MinIO — Worker (через Apply Engine) та runtime (для runs/ та memory/).

**Overlap:** Runtime (Mastra/Inngest) має write access до MinIO для `runs/`, `memory/`, run artifacts. Worker має write access для proposals, inbox entries, applied changes. Це два write paths до одного storage. Boundaries визначені (runtime пише лише у свої шляхи), але формально не зафіксовані як access control policy.

### 2.2 Orchestration authority (Inngest)

**Визначено чітко.**

[ЦІЛЬОВА] §2.3: "Inngest не містить бізнес-логіки агентів". [DRAKON] §5.2: "Inngest не парсить frontmatter і не читає pseudocode". Inngest контролює: коли запускати, retry policy, timeout, concurrency. Не контролює: що агент робить, як інтерпретувати instructions.

**Без overlap.** Чітке розмежування з Mastra.

### 2.3 Runtime interpretation authority (Mastra)

**Визначено чітко.**

[ЦІЛЬОВА] §2.4: "Mastra відповідає за як агент думає та діє". [DRAKON] §5.1: Mastra парсить frontmatter, створює agent instance, виконує. [КОНТРАКТ] §0: "Runtime є інтерпретатором, не власником".

**Без overlap** з Inngest. Є overlap з MinIO (write-memory, runs write) — див. §2.1.

### 2.4 Cognitive authority (NotebookLM via FastAPI)

**Визначено чітко.**

[МАНІФЕСТ] §4.2: "NotebookLM не приймає архітектурних рішень, не визначає UX, не керує процесами". [ЦІЛЬОВА] §2.2: "FastAPI не знає про агентів, Mastra, Inngest". [БАЗА] §5.2: "Відповідає строго по джерелах".

**Без overlap.** FastAPI — ізольований за інтерфейсом. Mastra звертається через tool, FastAPI не знає контексту агента.

### 2.5 Mutation authority (proposal approval)

**Визначено чітко** з одним винятком.

[INBOX] §4: Consent Gates визначені (Validation, Approval, Zone Consent, Agent Activation). Owner має exclusive approval authority. Auto-approve — під контролем Owner.

**Виняток:** `write-memory` та `runs/` write — mutations canonical storage без approval. Див. Інваріант 5 вище.

### 2.6 Visualization authority (Lovable frontend)

**Визначено чітко.**

[FRONTEND] повністю описує: frontend — projection, не authority. Auth enforcement на backend. UI guards — cosmetic.

**Без ambiguity.**

### 2.7 Зведена таблиця authority boundaries

| Authority | Компонент | Чітко визначено | Overlap |
|-----------|----------|----------------|---------|
| Storage | MinIO | Так | Runtime write paths (memory/, runs/) |
| Orchestration | Inngest | Так | Немає |
| Runtime interpretation | Mastra | Так | MinIO write (memory/, runs/) |
| Cognitive | NotebookLM/FastAPI | Так | Немає |
| Mutation approval | Owner via Worker | Так | write-memory bypasses approval |
| Visualization | Frontend | Так | Немає |

---

## РОЗДІЛ 3 — Конфлікти між документами

### Конфлікт 3.1: Розташування `runs/` — всередині чи поза папкою агента

**Опис:** [КОНТРАКТ] §1.1 розміщує `runs/` всередині папки агента: `agents/<slug>/runs/<run-id>/`. [ЦІЛЬОВА] §2.1 розміщує `runs/` на верхньому рівні бакета: `garden-agents/runs/<run-id>/`.

Це структурний конфлікт: два документи визначають різні шляхи для одних і тих же артефактів.

**Ризик:** Реалізація може обрати будь-який варіант, і другий документ стане невірним. Або реалізація спробує підтримати обидва шляхи, що створить плутанину.

**Рекомендоване уточнення:** Прийняти рішення: runs/ живуть **або** в папці агента (per-agent isolation, простіший access control) **або** на top-level (простіший cross-agent query). Зафіксувати одну структуру в обох документах.

---

### Конфлікт 3.2: Що runtime читає — `pseudocode.md` чи `_agent.md`

**Опис:** [DRAKON] §2.2 стверджує, що `pseudocode.md` — файл, який "Runtime читає для визначення послідовності дій". [DRAKON] §3.3 та [КОНТРАКТ] §2 стверджують, що runtime завантажує `_agent.md`, де pseudocode вбудований у Markdown body.

Два суперечливих твердження про entry point для runtime.

**Ризик:** Якщо runtime читає лише `_agent.md` — `pseudocode.md` стає надлишковим артефактом. Якщо runtime читає `pseudocode.md` окремо — механізм синхронізації з `_agent.md` body не визначений.

**Рекомендоване уточнення:** Зафіксувати: runtime читає **виключно** `_agent.md`. `pseudocode.md` є проміжним артефактом конвеєра (design-time artifact), не runtime artifact. Виправити формулювання у [DRAKON] §2.2.

---

### Конфлікт 3.3: `pseudocode.md` у структурі папки агента

**Опис:** [DRAKON] §2.1 включає `pseudocode.md` у структуру папки агента як окремий файл поряд з `_agent.md`. [КОНТРАКТ] §1.1 **не перелічує** `pseudocode.md` у канонічній структурі.

**Ризик:** Неясно, чи `pseudocode.md` є частиною канонічної папки агента чи ні. Це впливає на контракт: який набір файлів визначає агента?

**Рекомендоване уточнення:** Визначити: `pseudocode.md` або (a) входить у канонічну структуру папки (додати до [КОНТРАКТ] §1.1) або (b) є design-time artifact, що не зберігається після вбудовування в `_agent.md` (видалити з [DRAKON] §2.1 як окремий файл).

---

### Конфлікт 3.4: Proposals storage — у папці агента чи top-level

**Опис:** [КОНТРАКТ] §1.1 показує `runs/<run-id>/output/proposal.json` — proposals як output всередині runs. [INBOX] §3.4 визначає окрему структуру `garden-agents/proposals/pending/`, `proposals/approved/`, тощо — proposals на top-level.

Proposals мають два шляхи: як output run (per-agent) і як pending queue (system-wide).

**Ризик:** Низький, якщо інтерпретувати: run output містить **копію** proposal для audit trail, а `proposals/` — канонічну чергу для approval. Але це не зафіксовано явно.

**Рекомендоване уточнення:** Зафіксувати: `proposals/pending/` — канонічна черга для approval lifecycle. `runs/<run-id>/output/proposal.json` — snapshot для audit trail. Зазначити, що canonical proposal — в `proposals/`, а не в `runs/output/`.

---

### Конфлікт 3.5: DRAKON як обов'язковий vs опціональний

**Опис:** [DRAKON] формулює інваріанти так, ніби DRAKON — єдиний шлях визначення логіки: "DRAKON-діаграма є авторитетним джерелом логіки агента" (Інваріант 1), "Ланцюг трансформацій... не може бути пропущена" (§1.2). [КОНТРАКТ] §3.1 визначає два рівноправних шляхи: Path A (вручну) та Path B (через DRAKON). У Path A — DRAKON не використовується.

**Ризик:** Інваріант 1 з [DRAKON] формально порушується для агентів, створених через Path A.

**Рекомендоване уточнення:** Переформулювати [DRAKON] Інваріант 1: "Для агентів, визначених через DRAKON (поле `generated_from` присутнє), діаграма є авторитетним джерелом логіки". Для агентів Path A — авторитетне джерело = Markdown body `_agent.md`.

---

### Конфлікт 3.6: Frontend authority і DRAKON save path

**Опис:** [FRONTEND] §2.6 стверджує: "Збереження діаграми → `POST /inbox/submit` (action: `propose-drakon-update`) → Proposal → Approval → Apply до MinIO". Тобто навіть DRAKON save проходить через proposal lifecycle. [DRAKON] §4.1 sequence diagram показує: "DE → S3: Save .drakon.json" — пряме збереження без proposal.

**Ризик:** Два документи визначають різні шляхи збереження DRAKON-діаграми. Якщо DRAKON save проходить через proposals — це повільно для iterative design. Якщо напряму — це порушує proposal lifecycle для Owner.

**Рекомендоване уточнення:** Прийняти рішення: Owner save DRAKON-діаграми — (a) через proposal з auto-approve (зберігає audit trail, додає latency) або (b) прямий save (як зараз через Worker → GitHub, без proposal). Зафіксувати вибір в обох документах. Рекомендація: Owner DRAKON save = прямий (Owner є авторитетом над своїми діаграмами), але audit log пишеться.

---

## РОЗДІЛ 4 — Архітектурні розриви (undefined behavior)

### 4.1 Failure scenarios

#### 4.1.1 Runtime crash during execution

**UNDEFINED.** Жоден документ не визначає поведінку при краші Mastra під час виконання агента.

| Питання | Відповідь у документації |
|---------|------------------------|
| Що відбувається з поточним run? | Не визначено |
| Чи Inngest автоматично retry? | Імпліцитно так (durable execution), але не зафіксовано |
| Чи partial run зберігається у MinIO? | Не визначено: чи steps, записані до краші, залишаються? |
| Чи агент переходить у стан `error`? | [КОНТРАКТ] §4.3 визначає `active → error` при "критичній помилці", але критерії crash vs transient error не визначені |
| Чи proposal, створений до краші, залишається в Inbox? | Не визначено |

**Рекомендація:** Визначити: (a) Inngest retry policy для Mastra crash; (b) стан partial run (зберігається як `status: failed` з наявними steps); (c) proposals, створені до краші, залишаються `pending` (вони вже в Inbox).

#### 4.1.2 Proposal approval after contract change

**UNDEFINED.** Сценарій: агент виконується, створює proposal. Перед тим як Owner approve — `_agent.md` змінюється (нова версія, нові safe_outputs). Owner approve старий proposal, що був створений попередньою версією агента.

| Питання | Відповідь у документації |
|---------|------------------------|
| Чи перевіряється version match при approve? | Не визначено |
| Чи proposal зберігає agent_version? | Так: [КОНТРАКТ] §6.3 manifest.json має `agent_version` |
| Чи Apply Engine валідує version? | Не визначено |

**Рекомендація:** Визначити: Apply Engine може (a) ігнорувати version mismatch (Owner вирішив — Owner авторитет), або (b) показувати warning "agent version changed since proposal was created", або (c) require re-run. Рекомендація: (b) — warning без блокування, бо Owner — final authority.

#### 4.1.3 Partial artifact write

**UNDEFINED.** Сценарій: Apply Engine записує proposal у Git (commit), але MinIO write (proposal status → applied) не вдається. Або навпаки.

| Питання | Відповідь у документації |
|---------|------------------------|
| Чи Apply атомарний? | [INBOX] §3.5: "Apply — це атомарна операція. Часткові записи заборонені." Принцип зафіксований. |
| Як забезпечити атомарність між Git + MinIO? | Не визначено. Це два різних storage, distributed transaction не підтримується. |

**Рекомендація:** Визначити: (a) порядок operations (спочатку Git, потім MinIO status update; якщо MinIO fail — retry status update); (b) compensation mechanism (якщо Git commit failed — MinIO proposal → `failed`); (c) idempotency guarantees.

### 4.2 Concurrency scenarios

#### 4.2.1 Два run одного агента одночасно

**ЧАСТКОВО ВИЗНАЧЕНО.**

[ЦІЛЬОВА] §2.3: Inngest забезпечує "concurrency control — обмеження одночасних запусків одного агента". Принцип зафіксований, але:

| Питання | Відповідь у документації |
|---------|------------------------|
| Default concurrency limit? | Не визначено (1? configurable?) |
| Де визначається concurrency per agent? | Не визначено (у `_agent.md`? у Inngest config?) |
| Що відбувається при спробі запустити другий run? | Не визначено (queue? reject? wait?) |

**Рекомендація:** Визначити: default concurrency = 1 per agent. Визначити поведінку при спробі concurrent run: queued (Inngest native). Опціонально: поле `concurrency` у `_agent.md` frontmatter.

#### 4.2.2 Proposal approval після нового run

**UNDEFINED.** Сценарій: Agent run #1 створює proposal A. Agent run #2 створює proposal B (для того ж target). Owner approve proposal A, потім approve proposal B.

| Питання | Відповідь у документації |
|---------|------------------------|
| Чи виникає конфлікт при apply? | Не визначено |
| Чи перевіряється, що target не змінився? | Не визначено |
| Merge conflict resolution? | Не визначено |

**Рекомендація:** Визначити: proposals для одного target обробляються FIFO. Apply Engine перевіряє, що target не змінився з моменту створення proposal (optimistic concurrency: зберігати `target_hash` у proposal). Якщо конфлікт — proposal → `failed` з описом "target changed since proposal was created".

### 4.3 Contract evolution scenarios

#### 4.3.1 Зміна `_agent.md`

**ЧАСТКОВО ВИЗНАЧЕНО.**

[КОНТРАКТ] §0: "Зміна поведінки агента = зміна файлу `_agent.md` у MinIO". [DRAKON] §5.1: "Якщо `_agent.md` змінився між runs — поведінка агента змінюється автоматично".

| Питання | Відповідь у документації |
|---------|------------------------|
| Чи потрібен version bump? | [КОНТРАКТ] §2.2: `version` обов'язкове, semver. Але хто інкрементує і коли — не визначено. |
| Чи зміна `_agent.md` проходить через proposal? | Не визначено. Owner змінює напряму? Через Inbox? |
| Чи валідується новий `_agent.md`? | [КОНТРАКТ] §7: валідація при `draft → active`. А якщо агент вже `active` і `_agent.md` змінюється? Не визначено. |

**Рекомендація:** Визначити: (a) зміна `_agent.md` для active агента вимагає re-validation; (b) version bump при зміні — автоматичний чи manual; (c) механізм зміни — Owner пише напряму (він авторитет) чи через proposal (для audit trail).

#### 4.3.2 Зміна pseudocode (re-generation з DRAKON)

**ЧАСТКОВО ВИЗНАЧЕНО.**

[DRAKON] §1.2: "Якщо потрібно змінити поведінку — змінюється діаграма, і ланцюг проходить знову". [КОНТРАКТ] §3.2: конвеєр DRAKON → drakongen → agentExporter → `_agent.md`.

| Питання | Відповідь у документації |
|---------|------------------------|
| Чи автоматично перегенерується `_agent.md` при зміні діаграми? | Не визначено (manual trigger? auto?) |
| Чи конфлікт з ручними змінами body `_agent.md`? | [КОНТРАКТ] §3.4: якщо body змінено вручну, `generated_from` має бути видалений. Але enforcement не визначений. |
| Чи зберігається попередня версія `_agent.md`? | Не визначено (versioning через MinIO? через Git?) |

**Рекомендація:** Визначити: re-generation — manual trigger (Owner натискає "Re-export from DRAKON"). Auto re-generation при save діаграми — заборонена (може перезаписати ручні зміни). Versioning `_agent.md` — через semver у frontmatter + MinIO object versioning.

#### 4.3.3 Зміна memory files

**UNDEFINED.**

[КОНТРАКТ] §1.2: "`memory/` записується агентом, але контролюється Owner. Owner може видалити або відредагувати пам'ять агента через UI".

| Питання | Відповідь у документації |
|---------|------------------------|
| Формат memory files? | [КОНТРАКТ] §6.4: `observations.jsonl` — JSONL. Але schema не визначена. |
| Як агент читає memory? | Tool `read-memory`. Формат response не визначений. |
| Чи memory впливає на behavioral contract? | Імпліцитно так (агент читає memory і враховує у reasoning). Але це не частина формального контракту. |
| Чи memory access — read-all або filtered? | Не визначено. |
| Quota/size limit? | Не визначено. |

**Рекомендація:** Визначити: memory schema (JSONL з обов'язковими полями `ts`, `run`, `observation`), read-memory behavior (return last N entries), size limit (для контролю context window), memory pruning policy.

### 4.4 Recovery scenarios

#### 4.4.1 Restart orchestration layer

**ЧАСТКОВО ВИЗНАЧЕНО.**

[ЦІЛЬОВА] §1: "Якщо Mastra або Inngest втрачають стан — система відновлюється з MinIO". Принцип зафіксований, але деталі не визначені.

| Питання | Відповідь у документації |
|---------|------------------------|
| Чи in-flight runs відновлюються? | Inngest durable execution має це забезпечити, але не зафіксовано як вимога |
| Чи registry.json перебудовується? | [КОНТРАКТ] §5: "При розбіжності registry перебудовується з файлової системи". Тригер перебудови не визначений. |
| Startup sequence Agent Service? | Не визначено |

**Рекомендація:** Визначити: startup sequence (1. connect MinIO, 2. rebuild registry, 3. register Inngest functions, 4. resume pending events). In-flight runs: Inngest забезпечує replay.

#### 4.4.2 Replay execution lifecycle

**UNDEFINED.**

| Питання | Відповідь у документації |
|---------|------------------------|
| Чи можна replay failed run? | Не визначено |
| Чи replay використовує ту ж версію `_agent.md`? | Не визначено (current version? version at run time?) |
| Чи replay створює новий run_id? | Не визначено |

**Рекомендація:** Визначити: replay = new run з поточною версією `_agent.md` (не snapshot). Replay створює новий run_id. Replay не гарантує ідентичний результат (LLM nondeterminism).

---

## РОЗДІЛ 5 — Перевірка DRAKON → pseudocode → runtime chain

### 5.1 Логічна цілісність ланцюга

```
DRAKON → pseudocode → _agent.md → Mastra interpretation → proposal → Apply
  (1)       (2)          (3)            (4)                  (5)      (6)
```

| Перехід | Визначений | Механізм | Проблеми |
|---------|-----------|----------|----------|
| 1→2 | Так | `drakongen` / `pseudocodeToMarkdown()` | Автоматичний, детерміністичний. Без проблем. |
| 2→3 | Так | `agentExporter()` обгортає pseudocode у YAML frontmatter | **Не реалізований** ([БАЗА] §3.2: "агентний експорт не реалізований"). Механізм визначений, реалізація відсутня. |
| 3→4 | Так | Mastra парсить frontmatter + body, створює Agent instance | LLM інтерпретація: **nondeterministic**. Той самий pseudocode може дати різні tool call patterns. Це by design (LLM flexibility), але ризик execution divergence. |
| 4→5 | Так | Tool `create-proposal` → POST /inbox/submit | Через Worker → Inbox. Чітко визначено. |
| 5→6 | Так | Apply Engine: Owner approve → Git/MinIO write | Чітко визначено у [INBOX] §3.5. |

### 5.2 Чи runtime вводить behavioral logic, не визначену в storage?

**Відповідь: частково.**

Runtime (Mastra) **не містить** hardcoded logic жодного агента ([DRAKON] Інваріант 4). Однак:

1. **Tool implementation** визначає поведінку, не зафіксовану в storage. Tool `notebooklm-query` має конкретну реалізацію (HTTP call до FastAPI, формат запиту/відповіді). Ця реалізація — в коді Mastra, не в `_agent.md`. Агент каже "використай notebooklm-query", але **як** саме цей tool працює — визначено в runtime.

   **Оцінка:** Це допустимо. Tool — це interface. Реалізація інтерфейсу — в runtime. Визначення (коли і навіщо використовувати) — в storage. Розмежування коректне.

2. **LLM interpretation** вносить поведінку. Pseudocode каже `ЯКЩО нотатка.має_тег("summarized")`, але рішення "чи має тег" — це LLM judgment на основі даних. LLM може інтерпретувати цю умову по-різному залежно від формулювання.

   **Оцінка:** Це inherent nondeterminism LLM-based systems. Не порушення архітектури, але потребує awareness: pseudocode визначає intent, не exact execution path.

3. **Mastra orchestration logic** (max_steps iteration, tool call routing) — це runtime behavior, що не визначена у pseudocode. Pseudocode каже "зроби X", Mastra визначає "за скільки ітерацій і в якому порядку".

   **Оцінка:** Допустимо. `max_steps`, `temperature` — це конфігурація у frontmatter. Orchestration logic — в runtime. Розмежування коректне.

**Висновок:** Runtime не вводить **behavioral** logic (що робити). Runtime визначає **operational** logic (як саме виконати). Це коректне розмежування.

---

## РОЗДІЛ 6 — Перевірка storage authority integrity

### 6.1 Canonical rule

**[INBOX] §0:** "Жодна сутність у системі — людина, агент, зовнішній сервіс — не може змінити канонічні дані (MinIO, Git) напряму. Будь-яка зміна проходить через Inbox → Proposal → Approval → Apply."

### 6.2 Перевірка всіх write paths до MinIO

| Write path | Хто пише | Що пише | Через Proposal? | Оцінка |
|-----------|----------|---------|-----------------|--------|
| Agent definition (`_agent.md`) | Owner | Agent contract | **Не визначено** | ⚠️ Потребує уточнення |
| DRAKON files (`.drakon.json`) | Owner через Editor | Agent logic | **Суперечність** (див. Конфлікт 3.6) | ⚠️ Потребує рішення |
| `pseudocode.md` | `drakongen` (auto) | Generated pseudocode | Не через Proposal (auto-generated artifact) | ✅ Допустимо (design-time) |
| Inbox entries (`inbox/`) | Worker | Incoming intents | Не через Proposal (Inbox = pre-proposal) | ✅ Допустимо (Inbox — вхід до системи) |
| Proposals (`proposals/`) | Worker (від Inbox) | Proposal JSON | Не через Proposal (Proposal = сам механізм) | ✅ Допустимо (це сам proposal) |
| Proposal status change | Worker (Apply Engine) | Status update | **Через Approval Gate** | ✅ Коректно |
| Git commit (notes) | Worker (Apply Engine) | Note content | **Через Proposal + Approval** | ✅ Коректно |
| Run log (`runs/`) | Inngest/Mastra | Run metadata, steps | **Не через Proposal** | ⚠️ Не зафіксований виняток |
| Memory (`memory/`) | Mastra (write-memory) | Agent observations | **Не через Proposal** | ⚠️ Не зафіксований виняток |
| Audit log (`audit/`) | Worker | Audit entries | Не через Proposal (audit = запис факту) | ✅ Допустимо |
| Registry (`registry.json`) | System | Agent index | Не через Proposal (кеш) | ✅ Допустимо (кеш, не source of truth) |

### 6.3 Виявлені порушення

**Порушення 1: `write-memory` bypasses Proposal lifecycle**

Agent tool `write-memory` пише напряму у MinIO `memory/` без proposal. Це порушує формулювання [INBOX] §0, де **жодна сутність** не може змінити canonical storage напряму.

**Severity:** Середня. `memory/` — це operational data агента (спостереження, кеш), не knowledge content (нотатки, артефакти). Порушення формальне, не семантичне.

**Рекомендація:** Явно зафіксувати виняток: "Operational writes (runs/, memory/, audit/, registry.json) є винятками з proposal lifecycle. Вони не змінюють knowledge content і не потребують approval."

**Порушення 2: `runs/` writes bypass Proposal lifecycle**

Inngest/Mastra пишуть run log (manifest.json, steps/, output/) напряму у MinIO.

**Severity:** Низька. Run log — це запис факту виконання, не зміна knowledge.

**Рекомендація:** Включити у той самий виняток, що і memory/.

**Порушення 3: Agent definition changes — undefined path**

Зміна `_agent.md` Owner'ом не має визначеного шляху: через Proposal чи напряму?

**Severity:** Середня. Якщо Owner змінює `_agent.md` напряму — немає audit trail зміни. Якщо через Proposal — повільно для iterative development.

**Рекомендація:** Owner зміни `_agent.md` = прямий запис + audit log entry (без proposal). Owner є supreme authority; proposal потрібен для захисту від non-Owner changes.

---

## РОЗДІЛ 7 — Runtime-state divergence risk

### 7.1 Потенційні точки divergence

| # | Сценарій | Runtime state | Storage state | Divergence? |
|---|---------|---------------|---------------|-------------|
| 1 | Mastra кешує `_agent.md` | Стара версія в пам'яті | Нова версія в MinIO | **Так, якщо кешування** |
| 2 | Inngest durable state після run | Inngest зберігає step results | MinIO має run log | Ні (Inngest state — ефемерний) |
| 3 | `registry.json` vs `_agent.md` files | — | Registry — кеш; files — truth | **Так, якщо rebuild не працює** |
| 4 | Proposal у Inngest callback vs MinIO | Inngest знає proposalId | MinIO має proposal file | Ні (Inngest лише ID) |
| 5 | Agent status: `_agent.md` vs runtime | `_agent.md` status: active | Mastra може мати running instance | **Так, при pause → kill** |

### 7.2 Аналіз

**Сценарій 1 — Agent definition caching:**
Архітектура explicitly забороняє кешування: [DRAKON] Інваріант 6: "Runtime завантажує `_agent.md` з MinIO при кожному запуску". [DRAKON] §3.4: "Cached agent definitions — заборонений патерн".

**Висновок:** Якщо реалізація дотримується інваріанту — divergence неможливий. Інваріант достатній.

**Сценарій 3 — Registry divergence:**
[КОНТРАКТ] §5: "registry.json є кешем, не джерелом істини. При розбіжності registry перебудовується з файлової системи."

**Проблема:** Тригер перебудови не визначений. Якщо registry.json стає stale — frontend показує неактуальні дані. Потрібен механізм: (a) periodic rebuild, (b) rebuild on agent change, (c) rebuild on startup.

**Сценарій 5 — Agent status divergence:**
Owner призупиняє агента (`_agent.md` status: paused). Але в цей момент Mastra має running instance цього агента. Agent status у MinIO — `paused`, але run продовжується.

**Проблема:** Не визначено, чи зміна status → paused повинна (a) негайно зупинити running instance або (b) дозволити поточному run завершитися, а наступний не запускати.

**Рекомендація:** Визначити: pause = не запускати нових runs. Поточний run завершується (graceful). Якщо потрібна негайна зупинка — окрема операція `stop` (cancel Inngest event).

### 7.3 Архітектурна оцінка

Архітектура **адекватно запобігає divergence** для основних сценаріїв:
- No-caching principle усуває definition divergence
- MinIO-as-truth principle усуває state divergence
- Ephemeral runtime principle усуває persistent divergence

**Залишкові ризики:** registry staleness, pause-during-run behavior. Потребують уточнення, але не є архітектурними defects.

---

## РОЗДІЛ 8 — Migration consistency risk

### 8.1 Canonical storage authority

[МІГРАЦІЯ] визначає фази, де кожна залишає MinIO canonical storage authority без змін:

- Phase 0: proposals мігрують з KV → MinIO. **Ризик:** перехідний період з двома stores. [МІГРАЦІЯ] §4.1 визначає мітигацію: cutover замість поступової міграції. **Адекватно.**
- Phase 1–3: MinIO розширюється, не замінюється. **Без ризику.**
- Phase 4: gh-aw видаляється. Не впливає на storage authority. **Без ризику.**

**Оцінка:** Migration plan НЕ порушує canonical storage authority.

### 8.2 Proposal lifecycle

[МІГРАЦІЯ] Phase 0 встановлює proposal lifecycle **перед** впровадженням агентів. Це правильна послідовність: інфраструктура для approval створюється до того, як агенти почнуть генерувати proposals.

**Оцінка:** Migration plan НЕ порушує proposal lifecycle. Навпаки — він його встановлює як передумову.

### 8.3 Agent contract integrity

[МІГРАЦІЯ] Phase 1 вводить `_agent.md` loading з MinIO. Phase 2 додає Inngest orchestration. Phase 3 з'єднує з NLM та повним lifecycle.

**Потенційний ризик:** Phase 1 використовує тестовий агент "test-echo" без NLM. `_agent.md` тестового агента може мати спрощений контракт. Якщо спрощення стане precedent — production агенти можуть не відповідати повному контракту V1.

**Рекомендація:** Зафіксувати: тестовий агент Phase 1 відповідає повному контракту V1 (всі обов'язкові поля), але з `tools: [create-proposal]` (без NLM). Це мінімальний, але валідний контракт.

**Оцінка:** Migration plan НЕ порушує agent contract integrity за умови виконання рекомендації.

---

## РОЗДІЛ 9 — Рекомендовані архітектурні уточнення

### 9.1 Уточнення в документації

| # | Що уточнити | Де | Пріоритет |
|---|------------|-----|-----------|
| U1 | Роль `pseudocode.md`: окремий файл чи лише design-time artifact? Визначити одну позицію. | [DRAKON] §2.1, [КОНТРАКТ] §1.1 | Високий |
| U2 | Entry point runtime: тільки `_agent.md` (виправити [DRAKON] §2.2 формулювання). | [DRAKON] §2.2 | Високий |
| U3 | Розташування `runs/`: всередині папки агента або top-level. Обрати одне. | [КОНТРАКТ] §1.1, [ЦІЛЬОВА] §2.1 | Високий |
| U4 | `write-memory` та `runs/` write: зафіксувати як явні винятки з proposal lifecycle. Визначити категорію "operational writes". | [INBOX] §0, [КОНТРАКТ] §1.2 | Високий |
| U5 | Зміна `_agent.md` Owner: через proposal чи прямий запис? Зафіксувати path та audit policy. | [КОНТРАКТ], [INBOX] | Середній |
| U6 | DRAKON save path: через proposal чи прямий? Узгодити [FRONTEND] §2.6 та [DRAKON] §4.1. | [FRONTEND], [DRAKON] | Середній |
| U7 | DRAKON обов'язковість: переформулювати [DRAKON] Інваріант 1 для агентів Path A (без DRAKON). | [DRAKON] §6 | Середній |
| U8 | Маніфест "папка без агента = агент за замовчуванням" vs Контракт "папка без _agent.md = не агент": зафіксувати різницю між ідеологією та технічним контрактом. | [МАНІФЕСТ] §2.2, [КОНТРАКТ] §1.3 | Низький |
| U9 | Canonical proposals location: `proposals/` (system-wide queue) vs `runs/.../output/proposal.json` (per-run snapshot). Зафіксувати, що canonical = `proposals/`, run output = snapshot. | [КОНТРАКТ] §1.1, [INBOX] §3.4 | Низький |
| U10 | Dual source of truth (Git для notes, MinIO для agent system): зафіксувати як явне розмежування. | [БАЗА] §2 | Низький |

### 9.2 Що потрібно явно зафіксувати як invariant

| # | Новий інваріант | Обґрунтування |
|---|----------------|---------------|
| I1 | "Operational writes (runs/, memory/, audit/, registry.json) є винятком з proposal lifecycle. Вони не змінюють knowledge content." | Усуває формальне порушення Інваріанту 5 |
| I2 | "Runtime reads exclusively `_agent.md`. Усі інші файли (pseudocode.md, drakon/) — design-time artifacts, не runtime inputs." | Усуває конфлікт runtime entry point |
| I3 | "Owner changes to agent definitions (_agent.md, drakon/) — direct write + audit log. No proposal required for Owner's own agents." | Визначає Owner authority path |
| I4 | "Pause agent = no new runs. Current run completes gracefully." | Визначає pause semantics |
| I5 | "Default agent concurrency = 1. Concurrent run queued by Inngest." | Визначає concurrency behavior |

### 9.3 Що потребує clarification (відкриті питання)

| # | Питання | Залежності |
|---|---------|-----------|
| C1 | Як запускається re-generation `_agent.md` з DRAKON? Auto чи manual trigger? | [DRAKON] §4.1, [КОНТРАКТ] §3.2 |
| C2 | Чи зберігається version history `_agent.md` у MinIO (object versioning)? | [КОНТРАКТ] §2.2 |
| C3 | Memory schema, read-memory behavior, size limits, pruning policy. | [КОНТРАКТ] §1.2 |
| C4 | Registry rebuild trigger: startup? periodic? on-change? | [КОНТРАКТ] §5 |
| C5 | Replay semantics: new run_id, current `_agent.md` version, no determinism guarantee. | Жоден документ |
| C6 | Runtime crash: Inngest retry policy, partial run state, agent error transition criteria. | [КОНТРАКТ] §4.3 |
| C7 | Proposal conflict resolution: два proposals на один target, optimistic concurrency. | [INBOX] §3 |
| C8 | Apply atomicity: порядок operations Git → MinIO, compensation при partial failure. | [INBOX] §3.5 |

---

## РОЗДІЛ 10 — Фінальна оцінка архітектури

### АРХІТЕКТУРА ПОТРЕБУЄ УТОЧНЕНЬ

---

### Обґрунтування

Архітектурна документація демонструє **високий рівень цілісності** у фундаментальних принципах:

**Сильні сторони:**
- Принцип "MinIO = canonical storage" послідовно підтримується у всіх 7 документах
- Розмежування runtime (interpreter) vs storage (authority) чітке і узгоджене
- Proposal lifecycle як єдиний mutation mechanism — послідовно визначений
- Frontend як projection layer — без суперечностей
- Migration plan послідовний і не порушує фундаментальних інваріантів
- Authority boundaries між компонентами (Mastra, Inngest, Worker, FastAPI) чіткі

**Виявлені проблеми:**

1. **Структурні конфлікти** (3 конфлікти):
   - Розташування `runs/` (всередині vs top-level)
   - Runtime entry point (`pseudocode.md` vs `_agent.md`)
   - `pseudocode.md` у структурі папки (є чи немає)

   Це не архітектурні дефекти — це неузгоджені деталі специфікації, що виникли через еволюцію документів. Вирішуються вибором одного варіанту.

2. **Незафіксовані винятки** (2 винятки):
   - `write-memory` та `runs/` bypassing proposal lifecycle
   - Owner direct writes до agent definitions

   Це допустимі архітектурні рішення, але вони формально суперечать сформульованому інваріанту "proposal = єдиний механізм змін". Потребують явної фіксації як винятки з обґрунтуванням.

3. **Undefined behavior** (8 сценаріїв):
   - Runtime crash, partial writes, concurrent runs, pause-during-run, contract evolution, replay, proposal conflicts, registry rebuild

   Це найбільша зона ризику. Undefined behavior — це не помилка архітектури, а незавершеність специфікації. Кожен із цих сценаріїв потребує явного рішення до початку реалізації.

4. **Неоднозначність DRAKON** (1 проблема):
   - DRAKON позиціонується одночасно як "єдиний канонічний інструмент" та як "один з двох шляхів". Потребує чіткішого формулювання.

### Рівень зрілості

Архітектура перебуває на **рівні 4 з 5** за шкалою специфікації:

| Рівень | Опис | Поточний стан |
|--------|------|---------------|
| 1. Ідея | Бачення без деталей | ✅ Пройдено |
| 2. Принципи | Фундаментальні інваріанти | ✅ Пройдено |
| 3. Компоненти | Ролі, boundaries, contracts | ✅ Пройдено |
| 4. Специфікація | Детальні формати, lifecycles, state machines | ✅ Поточний рівень (з прогалинами) |
| 5. Operational readiness | Failure modes, recovery, concurrency, monitoring | ⬜ Потребує роботи |

### Вердикт

Архітектура **цілісна на рівні принципів і компонентів**. Фундаментальних протиріч не виявлено. Виявлені проблеми є **деталями специфікації**, що вирішуються уточненнями (Розділ 9), а не redesign.

Для переходу до реалізації необхідно:
1. Вирішити 3 структурні конфлікти (Розділ 3: U1, U2, U3)
2. Зафіксувати 2 категорії винятків (Розділ 6: I1, I3)
3. Визначити поведінку для 8 undefined scenarios (Розділ 4: C1–C8)

Жодне з цих уточнень не вимагає зміни фундаментальної архітектури.

---

*Цей документ є результатом архітектурного аудиту узгодженості. Він не пропонує нових компонентів, не змінює архітектуру і не вводить нових технологій. Він фіксує стан узгодженості та визначає необхідні уточнення.*
